{"pages":[],"posts":[{"title":"javascript中的数据类型","text":"原始数据类型ECMAScript中有5种原始数据类型 null undefine number boolean string typeof()运算符typeof()中有一个参数，即要检查的值，例如： console.log(typeof(123)); //number console.log(typeof(&apos;123&apos;)); //string console.log(typeof(true)); //boolean console.log(typeof(undefined)); //undefined console.log(typeof(function () {})); //function console.log(typeof([])); //object console.log(typeof({})); //object console.log(typeof(null)); //object 其中null检测为object是javascript最初实现时的一个错误，后来被ECMAScript沿用。现在被解释为是对象的占位符，从技术上来讲，null仍是一个原始值。 Undefined类型Undefined类型只有一个值，即undefined。当声明一个变量却没有给其定义时，默认值为undefined var a; console.log(a==undefined); //true undfined并不等同于未定义的值，但typeof()不能真正区分这两种值，如： var a; console.log(typeof(a)); //undefined console.log(typeof(b)); //undefined 虽然b没有被定义，但依然输出的是undefined。当对b使用其他运算符时会引发错误，如： console.log(b==undefined); 当函数无明确返回值时，返回的也是undefined，如： function test(){}; console.log(test()==undefined); //true ###Null类型Null类型是另一种只有一个值的数据类型，由于undefined是由null派生出的，所以ECMAScript把它们定义为相等 console.log(null==undefined); //true console.log(null===undefined); //false 尽管这两个值相等，但它们的含义不同。undifined是声明一个变量但却没定义，null则是表示尚未存在的对象。 ###Number类型Number类型既可以表示32位的整数，也可以表示64位的浮点数 ####十进制数 var a=64; ####八进制数 var b=071; 八进制数字面量的首数字必须是0，后面接不大于8的数 ####十六进制数 var c=0xf0; 十六进制数字面量前两个为0x，后接不大于f的数 ####浮点数浮点数中必须有小数点，小数点后必须至少有一位数字 var d=7.5; 浮点数在进行运算前是以字符串形式存储的 ####NaNNaN表示不是Number类型(Not a Number)，该情况大多数发生在数据类型转换失败的情况下，如将”blue”转成Number类型。 NaN另一个有趣的地方是它并不等于它本身 console.log(NaN==NaN); //false ####科学计数法当要表示一个非常大的数时，可以用一个数加e，后面乘以10的倍数 var num=5.678e7; //56780000 当要表示一个非常小的数时，可以用一个数后加-e var num=4e-6; //0.000004 ####特殊Number值Number.MAX_VALUE,Number.MIN_VALUE分别表示Number类型的最大值及最小值,所有ECMAScript数都必须在这之间 var max=Number.MAX_VALUE; var min=Number.MIN_VALUE; console.log(max+&apos;,&apos;+min); 也有专门的值表示无穷大，即infinite。Number.POSITIVE_INFINITY的值为infinite，表示正无穷。Number.NEGATIVE_INFINITY的值为-infinite，表示负无穷。判断一个数是否有穷，可以使用isFinite()方法，以确保该数是否无穷大 var iResult = iNum * some_really_large_number; if (isFinite(iResult)) { alert(&quot;finite&quot;); }else { alert(&quot;infinite&quot;); } ####String类型String类型是唯一一个没有固定大小的原始类型，可以用字符串存储0到更多的Unicode字符","path":"2018/04/10/ECMAScript中的原始数据类型/"},{"title":"call和apply的用法及区别","text":"call()和apply()的作用call与apply用于改变对象的执行上下文 什么是对象上下文？对象上下文是指当前函数运行的环境，我们在书写一个函数时常会用到this，而this就指向当前的执行上下文 为什么改变执行上下文假设我们寝室有A、B两人。A有一个电热水壶但是B没有，但是突然有一天，B由于某种原因需要用电热水壶，那么B是买一个还是借用A的呢？答案不言而喻。而call和apply就可以借用别的函数中的方法 call()和apply()的基本使用call()function.call(obj,arg1,arg2,...,argN); 调用apply()与call()必须是一个函数 第一个参数是要改变执行上下文的对象，也就是将this指向该对象 第二个参数是要传入function的参数apply()function.apply(obj,[args]); apply的使用方法基本与call相同 不同在于apply传入的参数必须是一个数组或是伪数组，但最终都会被转成伪数组传入argumens中 对象继承由于可以改变this指向，也就可以实现继承 function a() { this.name=&apos;aa&apos;; this.show=function () { console.log(this.name); } } function b() { a.call(this); this.show(); console.log(this.name); } b();","path":"2018/04/10/call和apply的用法及区别/"},{"title":"my first","text":"#一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 ‘#’号后面要加空格否则向前面一样，标题会失效，但是编译器显示正常 真·一级标题 斜体 加粗无序列表 candy gum fish 有序列表 candy gum fish 这是一个链接","path":"2018/04/09/my-first/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/04/02/hello-world/"}]}