{"pages":[],"posts":[{"title":"ECAMScript创建对象的方法","text":"原始的方式var ming=new Object; ming.name=&apos;小明&apos;; ming.gender=&apos;male&apos;; ming.age=13; ming.say=function(){ alert(this.name); } 原始的方式在要创建多个拥有相同属性名的实例对象时，会很麻烦 工厂方式function Person(){ var ming=new Object; ming.name=&apos;小明&apos;; ming.gender=&apos;male&apos;; ming.age=13; ming.say=function(){ alert(this.name); } return ming; } var a=Person(); var b=Person(); 我们可以通过给Person添加参数，使我们可以创建拥有相同属性但值不同的实例对象 function Person(name,gender,age){ var ming=new Object; ming.name=name||&apos;小明&apos;; ming.gender=gender||&apos;male&apos;; ming.age=age||13; ming.say=function(){ alert(this.name); } } var a=Person(&apos;小红&apos;,&apos;女&apos;,12); var b=Person(); 工厂方式有一个缺点，每次调用Person()函数时，都会创建新函数say()。这意味这每一个对象都拥有自己的say()函数，这会造成内存的浪费。有些开发者在工厂函数外定义函数，通过属性值指向该函数，从而避免这一问题 function say(){ alert(this.name); } function Person(name,gender,age){ var ming=new Object; ming.name=name||&apos;小明&apos;; ming.gender=gender||&apos;male&apos;; ming.age=age||13; ming.say=say; } var a=Person(&apos;小红&apos;,&apos;女&apos;,12); var b=Person(); 构造函数function Person(){ this.name=&apos;xiaoming&apos;; this.gender=&apos;male&apos;; this.age=13; this.say=function(){ alert(this.name); } } var a=new Person(); var b=new Person(); 构造函数没有像上面工厂函数一样在函数内创建对象，而是使用this关键字。使用new运算符时，在执行构造函数内第一行代码前，会创建一个对象，只有this才能访问这个对象。然后直接赋予this属性，默认情况下this是构造函数的返回值。 但构造函数和上面的工厂方式有着相同的问题：重复创建函数对象 原型方式function Person(){} Person.prototype.name=&apos;xiaoming&apos;; Person.prototype.gender=&apos;male&apos;; Person.prototype.age=13; Person.prototype.say=function(){ alert(this.name); } var a=new Person(); var b=new Person(); 虽然原型方式解决了重复创建函数对象的问题，但也有缺点。一是只有当对象创建完成后才能改变属性值，二是属性指向的是对象而不是函数时。函数共享没有问题，但对象却很少被多个实例共享 function Person(){} Person.prototype.name=&apos;xiaoming&apos;; Person.prototype.gender=&apos;male&apos;; Person.prototype.age=13; Person.prototype.friend=[&apos;mike&apos;,&apos;xiaohong&apos;]; Person.prototype.say=function(){ alert(this.name); } var a=new Person(); var b=new Person(); console.log(a.friend); //[&quot;mike&quot;,&quot;&quot;xiaohong&quot;] console.log(b.friend); //[&quot;mike&quot;,&quot;&quot;xiaohong&quot;] b.friend.push(&apos;lilei&apos;); console.log(a.friend); //[&quot;mike&quot;,&quot;&quot;xiaohong&quot;,&quot;lilei&quot;] console.log(b.friend); //[&quot;mike&quot;,&quot;&quot;xiaohong&quot;,&quot;lilei&quot;] ##混合构造函数/原型方式 function Person(name,gender,age){ this.name=name; this.gender=gender; this.age=13; this.friend=[&apos;mike&apos;,&apos;xiaohong&apos;]; } Person.prototype.say=function(){ alert(this.name); } 这种方式解决了上面所有的问题，并且时ECMAScript采用的主要方式，有其它方式的特点，却没有它们的缺点。不过仍有些人觉得这种方法不够完美 ##动态原型方式 function Person(){ this.name=name; this.gender=gender; this.age=13; this.friend=[&apos;mike&apos;,&apos;xiaohong&apos;]; if(typeof(Person._flag)==&apos;undefined&apos;){ Person.prototype.say=function(){ alert(this.name); } Person._flag=true; } } 若Person._flag未定义则构造函数将用原型方式定义对象方法，如果定义了则不再定义方法 ##混合工厂方式 function Person(){ var ming=new Object; ming.name=&apos;小明&apos;; ming.gender=&apos;male&apos;; ming.age=13; ming.say=function(){ alert(this.name); } return ming; } var a=new Person(); var b=new Person(); 与经典方式不同，这种方式使用 new 运算符，使它看起来像真正的构造函数 由于在Person() 构造函数内部调用了new运算符，所以将忽略第二个 new 运算符（位于构造函数之外），在构造函数内部创建的对象被传递回变量 这种方式在对象方法的内部管理方面与经典方式有着相同的问题。强烈建议：除非万不得已，还是避免使用这种方式。","path":"2018/04/11/ECAMScript创建对象的方法/"},{"title":"ECMAScript中的原始数据类型","text":"原始数据类型ECMAScript中有5种原始数据类型 null undefine number boolean string typeof()运算符typeof()中有一个参数，即要检查的值，例如： console.log(typeof(123)); //number console.log(typeof(&apos;123&apos;)); //string console.log(typeof(true)); //boolean console.log(typeof(undefined)); //undefined console.log(typeof(function () {})); //function console.log(typeof([])); //object console.log(typeof({})); //object console.log(typeof(null)); //object 其中null检测为object是javascript最初实现时的一个错误，后来被ECMAScript沿用。现在被解释为是对象的占位符，从技术上来讲，null仍是一个原始值。 Undefined类型Undefined类型只有一个值，即undefined。当声明一个变量却没有给其定义时，默认值为undefined var a; console.log(a==undefined); //true undfined并不等同于未定义的值，但typeof()不能真正区分这两种值，如： var a; console.log(typeof(a)); //undefined console.log(typeof(b)); //undefined 虽然b没有被定义，但依然输出的是undefined。当对b使用其他运算符时会引发错误，如： console.log(b==undefined); 当函数无明确返回值时，返回的也是undefined，如： function test(){}; console.log(test()==undefined); //true Null类型Null类型是另一种只有一个值的数据类型，由于undefined是由null派生出的，所以ECMAScript把它们定义为相等 console.log(null==undefined); //true console.log(null===undefined); //false 尽管这两个值相等，但它们的含义不同。undifined是声明一个变量但却没定义，null则是表示尚未存在的对象。 Number类型Number类型既可以表示32位的整数，也可以表示64位的浮点数 十进制数var a=64; 八进制数var b=071; 八进制数字面量的首数字必须是0，后面接不大于8的数 十六进制数var c=0xf0; 十六进制数字面量前两个为0x，后接不大于f的数 浮点数浮点数中必须有小数点，小数点后必须至少有一位数字 var d=7.5; 浮点数在进行运算前是以字符串形式存储的 NaNNaN表示不是Number类型(Not a Number)，该情况大多数发生在数据类型转换失败的情况下，如将”blue”转成Number类型。 NaN另一个有趣的地方是它并不等于它本身 console.log(NaN==NaN); //false 科学计数法当要表示一个非常大的数时，可以用一个数加e，后面乘以10的倍数 var num=5.678e7; //56780000 当要表示一个非常小的数时，可以用一个数后加-e var num=4e-6; //0.000004 特殊Number值Number.MAX_VALUE,Number.MIN_VALUE分别表示Number类型的最大值及最小值,所有ECMAScript数都必须在这之间 var max=Number.MAX_VALUE; var min=Number.MIN_VALUE; console.log(max+&apos;,&apos;+min); 也有专门的值表示无穷大，即infinite。Number.POSITIVE_INFINITY的值为infinite，表示正无穷。Number.NEGATIVE_INFINITY的值为-infinite，表示负无穷。判断一个数是否有穷，可以使用isFinite()方法，以确保该数是否无穷大 var iResult = iNum * some_really_large_number; if (isFinite(iResult)) { alert(&quot;finite&quot;); }else { alert(&quot;infinite&quot;); } String类型String类型是唯一一个没有固定大小的原始类型，可以用字符串存储0到更多的Unicode字符","path":"2018/04/10/ECMAScript中的原始数据类型/"},{"title":"call和apply的用法及区别","text":"call()和apply()的作用call与apply用于改变对象的执行上下文 什么是对象上下文？对象上下文是指当前函数运行的环境，我们在书写一个函数时常会用到this，而this就指向当前的执行上下文 为什么改变执行上下文假设我们寝室有A、B两人。A有一个电热水壶但是B没有，但是突然有一天，B由于某种原因需要用电热水壶，那么B是买一个还是借用A的呢？答案不言而喻。而call和apply就可以借用别的函数中的方法 call()和apply()的基本使用call()function.call(obj,arg1,arg2,...,argN); 调用apply()与call()必须是一个函数 第一个参数是要改变执行上下文的对象，也就是将this指向该对象 第二个参数是要传入function的参数apply()function.apply(obj,[args]); apply的使用方法基本与call相同 不同在于apply传入的参数必须是一个数组或是伪数组，但最终都会被转成伪数组传入argumens中 对象继承由于可以改变this指向，也就可以实现继承 function a() { this.name=&apos;aa&apos;; this.show=function () { console.log(this.name); } } function b() { a.call(this); this.show(); console.log(this.name); } b();","path":"2018/04/10/call和apply的用法及区别/"},{"title":"my first","text":"#一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 ‘#’号后面要加空格否则向前面一样，标题会失效，但是编译器显示正常 真·一级标题 斜体 加粗无序列表 candy gum fish 有序列表 candy gum fish 这是一个链接","path":"2018/04/09/my-first/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/04/02/hello-world/"}]}